
\documentclass{studrep}

\RequirePackage{tabularx}
% \RequirePackage{graphicx}

\graphicspath{{pics/}}

% \usepackage{showframe}

% pygmetize
\RequirePackage{minted}
\RequirePackage{indentfirst}
\usemintedstyle{tango} % bw

% \setmainfont{Times New Roman}

\setminted{autogobble,mathescape,linenos=true,fontsize=\small,breaklines}
\begin{document}
\thispagestyle{empty}
\begin{center}
Министерство науки и высшего образования Российской Федерации

Федеральное государственное бюджетное образовательное учреждение\\ высшего образования

«Иркутский государственный университет»\\
(ФГБОУ ВО «ИГУ»)

Институт математики и информационных технологий

Кафедра информационных технологий
\end{center}

\vfill
\begin{center}
  \textbf{\large ОТЧЕТ}

  по научно"=исследовательской работе
  % по производственной практике
  % по преддипломной практике   % и т.п.
  %\textbf{ ВЫПУСКНАЯ КВАЛИФИКАЦИОННАЯ РАБОТА\\
%БАКАЛАВРА}
\vspace{1em}

% по направлению 02.03.03 -- Математическое обеспечение и администрирование информационных систем

% профиль <<общий>>

\vspace{2em}
ИССЛЕДОВАНИЕ КОМПИЛЯТОРА ЯЗЫКА \verb|D|

\end{center}
\vfill

\noindent\begin{tabularx}{\textwidth} {
  >{\raggedright\arraybackslash}X
  >{\raggedright}X }
&

Студента \_ курса очного отделения\\
группы 02\_4\_-ДБ\\
Фамилия Имя Отчество\\[2em]

Руководитель:\\
к.~т.~н., доцент\\
\underline{\hspace{3cm}} Иванов Иван Иванович\\[2em]

Защищен с оценкой\\[1em] \underline{\hspace{3cm}}
%Допущена к защите\\
%Зав.каф., к.~т.~н., доцент\\
%\underline{\hspace{3cm}} Черкашин Евгений\\ \hspace{3cm} Александрович\\[2em]

\end{tabularx}
\vfill
\begin{center}
  Иркутск 2023
\end{center}
\clearpage

\tableofcontents

\chapter*{ВВЕДЕНИЕ}
\label{chap:intro}
% TODO: Add contents line

Реализация компиляторов языков программирования -- одно из основных направлений в области системного программирования, включающего разработку трансляторов (в общем смысле, т.е. и компиляторов и интерпретаторов).  Трансляторы языков программирования относятся к системам порождающего программирования (ПП), т.е. программным системам, задача которых создать исходный код или какой-либо другой объект по некоторому описанию, модели, исходному информационному объекту.  Применение ПП предполагает, что исходный конформационный объект меняется достаточно редко, поэтому имеет смысл повысить производительность целевой системы за счет представления предварительного анализа объекта в виде последовательности инструкций целевого вычислителя, реализующих уже результат анализа.  Сама процедура анализа выполняется один раз транслятором.

Разработка трансляторов позволяет решать следующие задачи:
\begin{itemize}
\item Разрабатывать новые системы программирования;
\item Переносить существующий программный код языка высокого уровня на новые вычислительные платформы, например, микроконтроллеры;
\item Разрабатывать языки описания предметной области, представляющие объекты предметной области в удобном для пользователя виде, а, затем, преобразовывать описание в какой-либо другой язык для решения задачи;
\item Проводить исследования в области системного программирования и защиты информации;
\item Развивать практические аспекты теории формальных языков.
\end{itemize}

\textbf{Целью} данной курсовой работы является исследование компилятора \verb|LDC| версии 2.0 языка программирования высокого уровня \verb|D|.

В курсовой работе решены следующие \textbf{задачи}:
\begin{enumerate}
\item Изучен язык программирования \verb|D|, параметры компилятора \verb|LDC2| и система сборки пакетов \verb|dub|.
\item Создана программа, микросервис веб, вычисляющий факториал передаваемого значения.
\item Настроена система сборки проекта, реализована сборка.
\item Исследовано использование аргументов компилятора в процессе сборки проекта.
\item Осуществлен запуск компилятора для исследуемого модуля с целью трансляции исходного кода в промежуточное представление (ПП).
\item Выявлен и проанализирован текст ПП, относящийся к исследуемому методу.
\end{enumerate}

\chapter{Язык D и среда программирования LDC}

Разработка D задумывалась как реинжениринг языка C++ с целью избавиться от наиболее существенных недостатков исходного языка и внедрить в него современные архитектурные решения. При создании языка D была сделана попытка соединить производительность компилируемых языков программирования с безопасностью и выразительностью динамических \cite{wikipedia}.

Первоначально автор предполагал назвать язык «Mars», но из-за преемственности по отношению к C++ в обсуждениях язык постоянно называли «D», в результате именно это название и закрепилось за проектом.

Стабильная версия компилятора 1.0 вышла 2 января 2007. Вскоре после выхода компилятора 17 июня 2007 года автор перевёл версию 1 в режим поддержки и приступил к разработке версии 2.0, которая изначально не гарантировала обратной совместимости. Эта версия (последняя в настоящее время мажорная версия D) развивается и по сей день.

D реализует пять основных парадигм программирования — императивное, ООП, метапрограммирование, функциональное программирование и параллельные вычисления (модель акторов).

D использует сборщик мусора для управления памятью, однако возможно и ручное управление с помощью перегрузки операторов new и \texttt{delete}, а также с помощью \texttt{malloc} и \texttt{free}, аналогично C. Сборщик мусора можно включать и выключать вручную, можно добавлять и удалять области памяти из его видимости, принудительно запускать частичный или полный процесс сборки. Существует подробное руководство, описывающее различные схемы управления памятью в D для тех случаев, когда стандартный сборщик мусора неприменим.

D относится к семейству C-подобных языков, в общих чертах его синтаксис похож на C/C++/C\#, Java. При разработке языка соблюдается принцип: код, одинаково допустимый и в C, и в D, должен вести себя одинаково.

«Hello, world!» на D:
\begin{minted}{D}
import std.stdio;

void main()
{
    writeln ("Hello, world!");
}
\end{minted}
Так же, как в C, функция main() является точкой входа.

Конструкции \texttt{if}, \texttt{for}, \texttt{while}, \texttt{do-while} выглядят и работают аналогично C/C++. Инструкция множественного выбора \texttt{switch} выглядит аналогично C++, но допускает переменные в метках ветвей \texttt{case} и требует, чтобы каждая ветвь case завершалась \texttt{break} или \texttt{return}; для перехода на следующую ветвь после обработки текущей необходимо использовать специальную конструкцию \texttt{goto case}. Также запрещены конструкции \texttt{switch} без ветви \texttt{default}.

Из дополнительных управляющих конструкций можно отметить \texttt{static if} — инструкцию для условной компиляции (условие проверяется статически и в код включается содержимое той ветви, которая ему соответствует), оператор полного множественного выбора \texttt{final switch} — в отличие от обычного switch, он работает только со значениями enum, а компилятор статически проверяет, что в выборе учтены все возможные варианты и выдаёт ошибку в противном случае. Также есть цикл по коллекции \texttt{foreach}.

В D встроена система разбиения программы на модули (пакеты), обеспечивающая раздельную компиляцию и контролируемый импорт-экспорт. Система пакетов напоминает принятую в Java или Go: пакеты образуют иерархическую структуру, естественно отображаемую на дерево файловой системы. В отличие от C++, в D нет глобального пространства имён, каждое имя определяется в каком-либо пакете. С помощью инструкции \texttt{import} модуль программы может импортировать пакет, сделав доступными все имеющиеся в нём определения. Обращение к импортированным именам может выполняться с квалификацией: «\texttt{имя\_пакета.имя\_объекта}».

Язык предусматривает ряд средств, направленных на обеспечение удобной работы с импортируемыми именами. Есть возможность переименования пакета при импорте, задания альтернативного имени (алиаса) импортируемого пакета, импорта конкретных имён. Кроме того, язык разрешает без каких-либо дополнительных инструкций использовать импортированные имена без квалификации именем пакета. Однако действует ограничение: если в области видимости есть более одного подходящего определения встреченного в программе имени, то компилятор выдаёт ошибку и требует, чтобы имя было явно квалифицировано. Это предотвращает так называемый «угон имён», когда при добавлении в списки импорта нового пакета компилятор начинает связывать некоторое имя в программе не с тем определением, с которым оно связывалось ранее.

В D юнит-тесты являются частью языка, их можно использовать без подключения дополнительных библиотек или фреймворков.

\begin{minted}{D}
import std.stdio;

int first (int[] arr) {
    return arr[0];
}

unittest {
    int[] arr1 = [1, 2, 3];
    int[] arr2 = [10, 15, 20];

    assert(first(arr1) == 1);
    assert(first(arr2) == 10);
}

void main() {
    // ...
}
\end{minted}

\section{Компилятор \texttt{LDC}}

Проект LDC направлен на создание переносимого компилятора языка программирования D с современными возможностями оптимизации и генерации кода. Компилятор использует официальный набор утилит компилятора (так называемый <<фронтенд>>) \texttt{DMD} для поддержки последней версии D2 и опирается на библиотеки \texttt{LLVM Core} для генерации кода \cite{ldcwiki}.

Исходный код LDC является полностью открытым; части кода, не взятые/адаптированные из других проектов, лицензированы соглашением BSD.

LDC - это полностью общедоступный проект, поэтому любой вклад в разработку приветствуется. Например, если вы хотите заняться разработкой компиляторов, то, по некоторым данным, дополнение LDC новыми полезными функциями -- хороший первый шаг, особенно потому, что использованная в компиляторе библиотека LLVM очень удобна в работе. Чтобы начать работу, просмотрите список нереализованных задач, найдите ту, которая понравится (некоторые из них специально помечены как <<junior jobs>>), и работайте над исправлением - и, конечно, не стесняйтесь спрашивать совета в списке рассылки или на канале IRC. Список функций/улучшений, которые можно добавить в LDC, можно посмотреть в разделе <<Идеи проектов LDC>>. Также приветствуется разработка и поддержка пакетов LDC в дистрибутивах ОС, в частности, в Debian и его производных.

Компилятор \texttt{ldc2} (пакета LDC), в целом, работает аналогично референтному компилятору Digital~Mars~D, как увидим дальше, удачно компилирует проект, но реализует процедуру компиляции при помощи библиотеки (так называемого <<бэкенда>>) \texttt{LLVM} (Low level virtual machine) \cite{llvm}.  Это его свойство позволяет использовать компилятор \texttt{ldc2} для создания межъязыковых программных систем, интегрированных на уровне инструкций промежуточного представления (Intermediate representation, IR) скопированной программы, аналогично проекту \texttt{.NET} \cite{dotnet}.  Но, в отличие от \texttt{.NET}, который порождает код виртуальной машины \texttt{MSIL}, транслируемый <<на лету>> (just in time, JIT) во время исполнения программы в машинный код микропроцессора, IR может и интерпретироваться, и транслироваться в код микропроцессора во время компиляции, т.е. до непосредственного исполнения.  При этом сборку исполняемого модуля и оптимизацию программного кода можно производить еще в промежуточном представлении, что, в общем случае, улучшает производительность результирующего бинарного файла.

Список ключей компилятора \texttt{ldc2} можно получить при помощи команды \texttt{ldc2 --help}. Список ключей приведен в Приложении~\ref{chap:cmds} на стр.
~\pageref{chap:cmds}.

\begin{minted}{text}

\end{minted}

\chapter{Проектирование и реализация микросервиса}

В качестве приложения спроектируем небольшой REST-сервис при помощи библиотеки \texttt{HUNT}.  Библиотека позволяет разрабатывать WEB-сервера при помощи определения отображений \texttt{URL} на функции и методы экземпляров классов D.  Поддерживается шаблон проектирования MVC (Model-View-Controller) \cite{mvc}.

Пусть сервис реализует три функции:
\begin{itemize}
\item Выводит по запросу текущую дату и время,
\item Реализует эхо-запрос: возвращает текстовое сообщение, переданное в аргументе,
\item На запрос вычисления факториала (<<полезная>> функция) возвращает вычисленное число; аргумент передается в URL.
\end{itemize}

Для реализации REST необходимо определиться какие на сервере существуют объекты.  В нашем случае все три функции можно <<приписать>> (инкапсулировать в) некоторый анонимный объект-синглтон (имеющийся в единственном экземпляре), соответственно, функции будут его методами.

Следующий этап -- это отображение функций на тип запроса (\texttt{GET}, \texttt{PUT}, \texttt{PUSH} и т.д.).  Требования к нашему сервису представляют собой две функции с одним параметром, и одно возвращаемое значение (дата/время).  Структура входных параметров простая -- единичные значения типа Целое и Строка.  Следовательно для реализации запросов достаточно использования команды протокола HTTP \texttt{GET}.


Сформируем файл отображения URL на методы класса D, реализующего запросы:
\begin{minted}{text}
#
# [GET,POST,PUT,*,...]    path    controller.method
# Symbol* can accept all request method
#

GET   /             index.index
POST  /index        index.index
*     /home         index.index
GET   /api/test     api.testApi
GET   /api/echo/{msg<.+>}/     api.echo
GET   /api/fact/{n<\d+>}/      api.fact
\end{minted}
Здесь в первом столбце представлен тип HTTP-запроса, во втором -- шаблоны URL, некоторые включают специальные языковые конструкции для распознавания аргумента запроса. Третий столбец -- образ (адрес) метода: \texttt{api.*} -- запросы на выполнение требуемых функций.  Кроме необходимых функции в сервере реализованы также вспомогательные запросы, выполняющие сервисные задания.

Параметр запроса, например, как в строке (10) приведенной выше конфигурации, передается параметром в метод \verb|echo| контроллера \verb|ApiController| (строка 28 в тексте программы ниже).  Формат параметра позволяет указывать тип данного и проводить его предварительную верификацию еще до передачи в метод контроллера.  В случае, если параметр не подходит к формату, система Hunt выдает ошибку 500 (ошибка сервера).
\begin{minted}{d}
// файл app/controller/ApiController.d
// -----------------------------------

module app.controller.ApiController;

import hunt.framework;
import std.json : JSONValue;
import std.stdio;
import std.conv;

class ApiController : Controller
{
  mixin MakeController;
  @Action
  JsonResponse testApi() {
    import std.datetime;
    import std.datetime.date : DateTime;

    auto dt = Clock.currTime();
    auto dts = dt.toISOExtString();
    JSONValue js;
    js["currtime"] = dts;
    JsonResponse resp = new JsonResponse(js);
    return resp;
  }

  @Action
  JsonResponse echo(string msg) {
    JSONValue js;
    js["echo"] = msg;
    auto resp = new JsonResponse(js);
    return resp;
  }

  @Action
  JsonResponse fact(string n) {
    JSONValue js;
    auto res = fact(to!int(n));
    js["result"] = to!string(res);
    auto resp = new JsonResponse(js);
    return resp;
  }

  int fact(int n) {
    if (n==0) return 1;
    if (n==1) return 1;
    return n*fact(n-1);
  }
}
\end{minted}

Представленный выше контроллер решает все поставленные задачи.  Каждый метод контроллера обрабатывает \verb|GET|-запросы, т.е., параметры запроса передаются только через параметры методов контроллера.  Возвращаемое значение представляется в виде \verb|JSON|-структуры.  Например, метод \verb|fact(string n)|, возвращает структуру
\begin{minted}{json}
{"result":"6"}
\end{minted}

Пример сборки и запуска проекта продемонстрированы в следующем фрагменте текста.  Сборка осуществляется командой \texttt{dub run --compiler=ldc2}, где ключ \texttt{--compiler=} используется для указания компилятора, которым собирается проект.  В нашем случае -- \texttt{ldc2}, поддерживающий промежуточное представление..

\begin{minted}{text}
  stud@sysrescue:~/projects/webapp$ dub run --compiler=ldc2
    Starting Performing "debug" build using ldc2 for x86_64.
  Up-to-date hunt 1.7.17: target for configuration [library] is up to date.
  Up-to-date hunt-extra 1.2.3: target for configuration [library] is up to date.
  Up-to-date hunt-net 0.7.1: target for configuration [default] is up to date.
  Up-to-date hunt-http 0.8.2: target for configuration [default] is up to date.
  Up-to-date protobuf 0.6.2: target for configuration [protobuf] is up to date.
  Up-to-date grpc 0.5.0-beta.2: target for configuration [library] is up to date.
  Up-to-date hunt-redis 1.4.1: target for configuration [library] is up to date.
  Up-to-date hunt-cache 0.10.1: target for configuration [library] is up to date.
  Up-to-date hunt-console 0.4.0: target for configuration [hunt-console] is up to date.
  Up-to-date hunt-sql 1.6.0: target for configuration [library] is up to date.
  Up-to-date hunt-database 2.3.6: target for configuration [default] is up to date.
  Up-to-date hunt-validation 0.5.0: target for configuration [library] is up to date.
  Up-to-date hunt-entity 2.8.1: target for configuration [library] is up to date.
  Up-to-date hunt-openssl 1.0.5: target for configuration [library] is up to date.
  Up-to-date hunt-jwt 0.2.0-beta.4: target for configuration [library] is up to date.
  Up-to-date hunt-security 0.6.0: target for configuration [library] is up to date.
  Up-to-date hunt-shiro 1.3.1: target for configuration [library] is up to date.
  Up-to-date poodinis 8.1.3: target for configuration [library] is up to date.
  Up-to-date hunt-framework 3.4.6: target for configuration [library] is up to date.
  Up-to-date webapp ~master: target for configuration [application] is up to date.
    Finished To force a rebuild of up-to-date targets, run again with --force
     Running webapp


 ___  ___     ___  ___     ________      _________
|\  \|\  \   |\  \|\  \   |\   ___  \   |\___   ___\     Hunt Framework 3.4.6
\ \  \\\  \  \ \  \\\  \  \ \  \\ \  \  \|___ \  \_|
 \ \   __  \  \ \  \\\  \  \ \  \\ \  \      \ \  \      Listening: 0.0.0.0:8080
  \ \  \ \  \  \ \  \\\  \  \ \  \\ \  \      \ \  \     TLS: Disabled
   \ \__\ \__\  \ \_______\  \ \__\\ \__\      \ \__\
    \|__|\|__|   \|_______|   \|__| \|__|       \|__|    https://www.huntframework.com


Try to browse http://0.0.0.0:8080
\end{minted}

Работоспособность сервера проверим в отдельном окне, выполнив команду \texttt{ps -FC webapp}, где \texttt{-F} требует от программы представить вывод в подробной форме, а \texttt{-C} показывает различные статистические данные подсистемы распределения вычислительных ресурсов по отношению к нашему процессу.

\begin{minted}{text}
stud@sysrescue:~/projects/webapp/source/app/controller$ ps -FC webapp
UID          PID    PPID  C    SZ   RSS PSR STIME TTY          TIME CMD
stud       18551   18544  0 163131 37192  0 17:25 pts/1    00:00:00 /home/stud/projects/webapp/webapp
\end{minted}
Таким образом, мы убеждаемся, что процесс сервера запущен, привязан к виртуальному терминалу \texttt{pts/1} и находится в режиме ожидания запросов (соединений клиентов).

Далее протестируем работоспособность функций REST, реализованных в сервисе. Для этого используем утилиту \texttt{curl}, выполняющую функции HTTP-клиента, но работающую в командной строке.  При помощи этой утилиты можно выполнять весь спектр запросов REST, передавать и получать данные и файлы.  Выполним три запроса: собственно запрос на сервис, вычисление факториала от аргумента; запрос текущей даты в стандартном интернет-формате; тестовое сообщение (эхо-сервис).

\begin{minted}{bash}
stud@sysrescue:~/projects/webapp/source/app/controller$ curl http://localhost:8080/api/fact/9
{"result":"362880"}
stud@sysrescue:~/projects/webapp/source/app/controller$ curl http://localhost:8080/api/test
{"currtime":"2023-11-07T17:25:59.8807696"}
stud@sysrescue:~/projects/webapp/source/app/controller$ curl http://localhost:8080/api/echo/message-to-test
{"echo":"message-to-test"}
\end{minted}
В приведенном выше примере продемонстрирована работоспособность сервиса при правильных входных данных.

Следующий пример демонстрирует ответ сервера при неправильном входном значении.
\begin{minted}{html}
  <!--
$ stud@sysrescue:~/projects/webapp/source/app/controller$ curl http://localhost:8080/api/fact/9e
  -->
<!doctype html>
<html lang="en">
    <meta charset="utf-8">
    <title>404 Not Found</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>

        * {
            line-height: 3;
            margin: 0;
        }

        html {
            color: #888;
            display: table;
            font-family: sans-serif;
            height: 100%;
            text-align: center;
            width: 100%;
        }

        body {
            display: table-cell;
            vertical-align: middle;
            margin: 2em auto;
        }

        h1 {
            color: #555;
            font-size: 2em;
            font-weight: 400;
        }

        p {
            margin: 0 auto;
            width: 90%;
        }

    </style>
</head>
<body>
    <h1>404 Not Found</h1>
    <p>Sorry!! Unable to complete your request :(</p>

</body>
</html>
\end{minted}

Таким образом, разработанное серверное приложение функционирует согласно требованиям.

\chapter{Исследование скомпилированного кода}

Рассмотрим фрагмент контроллера, реализующий вычисление факториала.
\begin{minted}{d}
module app.controller.ApiController;

import hunt.framework;
import std.json : JSONValue;
import std.stdio;
import std.conv;

class ApiController : Controller
{
  mixin MakeController;

  // . . . . . . . . . . . . . .

  @Action
  JsonResponse fact(string n) {
    JSONValue js;
    auto res = fact(to!int(n));
    js["result"] = to!string(res);
    auto resp = new JsonResponse(js);
    return resp;
  }

  int fact(int n) {
    if (n==0) return 1;
    if (n==1) return 1;
    return n*fact(n-1);
  }
}
\end{minted}

Метод \verb-int fact(int n)- конвертирован в промежуточное представление, в результате получен следующий текст, представленный далее.  Интересные моменты прокомментированы в тексте на русском языке.

%\caption{Промежуточное представление метода fact}
\begin{minted}{llvm}
; [#uses = 1]
; Function Attrs: uwtable
define i32 @_D3app10controller13ApiControllerQp4factMFiZi
    (%app.controller.ApiController.ApiController* nonnull %.this_arg, i32 %n_arg) #0 {
  ; Длинное название функции обусловлено вхождением исходного метода
  ; в контексты пакета app.controller и модуль ApiController.
  ; В метод в качестве первого аргумента передается указатель
  ; на экземпляр класса ApiController - this.
  %this = alloca %app.controller.ApiController.ApiController*, align 8 ; [#uses = 3, size/byte = 8]
  %n = alloca i32, align 4  ; выделение памяти для n [#uses = 5, size/byte = 4]
  store %app.controller.ApiController.ApiController* %.this_arg, %app.controller.ApiController.ApiController** %this, align 8
  store i32 %n_arg, i32* %n, align 4 ; сохранение входного n в локальную переменную n
  %1 = load i32, i32* %n, align 4 ; загрузка локальной n; [#uses = 1]
  %2 = icmp eq i32 %1, 0 ; сравнение ее с 0       ; [#uses = 1]
  br i1 %2, label %if, label %endif ; если больше 0, переход на метку endif

if:                                               ; preds = %0
  ret i32 1 ; если n = 0 то вернуть в качестве результата 1.

dummy.afterreturn:                                ; No predecessors!
  br label %endif ; ненужный код, ужаляется оптимизатором.

endif:                                            ; preds = %dummy.afterreturn, %0
  %3 = load i32, i32* %n, align 4                 ; [#uses = 1]
  %4 = icmp eq i32 %3, 1 ; сравнение n с 1        ; [#uses = 1]
  br i1 %4, label %if1, label %endif2 ; если больше, перейти на метку endif2

if1:                                              ; preds = %endif
  ret i32 1 ; fact(1) = 1

dummy.afterreturn3:                               ; No predecessors!
  br label %endif2

endif2:                                           ; preds = %dummy.afterreturn3, %endif
  %5 = load i32, i32* %n, align 4                 ; [#uses = 1]
  %6 = load %app.controller.ApiController.ApiController*, %app.controller.ApiController.ApiController** %this, align 8 ; [#uses = 1]
  %7 = getelementptr inbounds %app.controller.ApiController.ApiController, %app.controller.ApiController.ApiController* %6, i32 0, i32 0 ; [#uses = 1, type = [38 x i8*]**]
  %8 = load [38 x i8*]*, [38 x i8*]** %7, align 8 ; [#uses = 1]
  %"fact@vtbl" = getelementptr inbounds [38 x i8*], [38 x i8*]* %8, i32 0, i32 36 ; [#uses = 1, type = i8**]
  %9 = load i8*, i8** %"fact@vtbl", align 8       ; загрузка адреса таблицы виртуальных методов
  %fact = bitcast i8* %9 to i32 (%app.controller.ApiController.ApiController*, i32)* ; вычисление адреса Fact
  %10 = load %app.controller.ApiController.ApiController*, %app.controller.ApiController.ApiController** %this, align 8 ; [#uses = 1]
  %11 = load i32, i32* %n, align 4                ; [#uses = 1]
  %12 = sub i32 %11, 1                            ; n1 = n-1
  %13 = call i32 %fact(%app.controller.ApiController.ApiController* nonnull %10, i32 %12) ; вычисление fact(n-1)
  %14 = mul i32 %5, %13                           ; %13 * схраненное значение n
  ret i32 %14   ; возврат значения факториала.
}
\end{minted}

Как видно из примера, все строки исходной программы преобразовались в промежуточное представление.  Так же к ним добавлены команды, например в строках 36-42, где решаются задачи диспетчеризации виртуальных методов.  Получается, что все методы в \verb|D| виртуальные, что одновременно упрощает компилятор, но чуть-чуть замедляет процесс исполнения программы.

\chapter*{ЗАКЛЮЧЕНИЕ}

В результате выполнения курсовой работы получен интересный факт о компиляторе \verb|ldc2| языка \verb|D|.  Оказывается все методы экземпляров некоторого класса -- виртуальные.  В документации по языку этот факт не описан явным образом, но исследование компилятора, проведенное в данной курсовой работе, показало его наличие.  Как язык программирования для пользовательских приложений \verb|D| вполне пригоден, так как использование только виртуальных методов упрощает компилятор, соответственно, делая его более простым. Однако такой подход несколько сказывается на производительности исполняемого кода.

В процессе реализации курсовой работы решены следующие задачи:
\begin{enumerate}
\item Изучен язык программирования \verb|D|, параметры компилятора \verb|LDC2| и система сборки пакетов \verb|dub|.
\item Создана программа, микросервис веб, вычисляющий факториал передаваемого значения, в сервисе реализовано четыре полезные функции.
\item Настроена система сборки проекта, реализована сборка.
\item Исследовано использование аргуметов компилятора в процессе сборки проекта.
\item Осуществлен запуск компилятора для исследуемого модуля с целью трансляции исходного кода в промежуточное представление.
\item Выявлен и проанализирован текст промежуточного представления, относящийся к исследуемому методу.
\end{enumerate}

\begin{thebibliography}{9}
\bibitem{wikipedia} D (язык программирования), Материал из Википедии — свободной энциклопедии -- URL:~\url{https://ru.wikipedia.org/wiki/D_(язык_программирования)}
\bibitem{ldcwiki} LDC Wiki -- URL:~\url{https://wiki.dlang.org/LDC}
\bibitem{llvm} The LLVM Compiler Infrastructure -- URL:~\url{https://llvm.org/}
\bibitem{dotnet} Build. Test. Deploy. -- URL:~\url{https://dotnet.microsoft.com/}
\bibitem{mvc} Model–view–controller, Материал из Википедии — свободной энциклопедии -- URL:~\url{https://en.wikipedia.org/wiki/Model–view–controller}
\end{thebibliography}

\appendices

\appendix
\chapter{Исходный код программ}

Здесь приводится \texttt{main}-функция приложения -- \texttt{REST}-сервера, реализованного при помощи библиотеки обратного вызова (фреймворка) HUNT.
\begin{minted}{d}
// main.d
//-------
module main;

import hunt.framework;
import hunt.logging;

void main(string[] args)
{
  LogConf conf;
  logLoadConf(conf);
  app().run(args);
}
\end{minted}

Данный файл -- основной, он реализует <<полезную>> функцию -- вычисление факториала.  Доступ к функции осуществляется согласно архитектуре REST при помощи \texttt{GET}-запроса.

\begin{minted}{d}
// файл app/controller/ApiController.d
// -----------------------------------

module app.controller.ApiController;

import hunt.framework;
import std.json : JSONValue;
import std.stdio;
import std.conv;

class ApiController : Controller
{
  mixin MakeController;
  @Action
  JsonResponse testApi() {
    import std.datetime;
    import std.datetime.date : DateTime;

    auto dt = Clock.currTime();
    auto dts = dt.toISOExtString();
    JSONValue js;
    js["currtime"] = dts;
    JsonResponse resp = new JsonResponse(js);
    return resp;
  }

  @Action
  JsonResponse echo(string msg) {
    JSONValue js;
    js["echo"] = msg;
    auto resp = new JsonResponse(js);
    return resp;
  }

  @Action
  JsonResponse fact(string n) {
    JSONValue js;
    auto res = fact(to!int(n));
    js["result"] = to!string(res);
    auto resp = new JsonResponse(js);
    return resp;
  }

  int fact(int n) {
    if (n==0) return 1;
    if (n==1) return 1;
    return n*fact(n-1);
  }
}
\end{minted}

Данный модуль используется для проверки работоспособности фреймворка Hunt.
\begin{minted}{d}
// файл app/controller/ApiController.d
// -----------------------------------

module app.controller.IndexController;

import hunt.framework;

class IndexController : Controller
{
  mixin MakeController;

  @Action
  string index()
  {
    return "Hello world!";
  }

}
\end{minted}

Для запуска сервера необходим конфигурационный модуль его настройки.
\begin{minted}{ini}
#
# файл config/application.conf
#
http.address = 0.0.0.0
http.port = 8080
http.allowOrigin=*
http.allowMethods=*
http.allowHeaders=DNT,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type
http.enableCors=true

hunt.log.level= DEBUG
hunt.log.path= ./log
hunt.log.file= log.txt
hunt.log.maxSize = 8M
hunt.log.maxNum= 10
\end{minted}

Интерфейс сервера REST настраивается следующим образом:
\begin{minted}{text}
#
# Файл config/routes
#
#
# [GET,POST,PUT,*,...]    path    controller.method
# Symbol* can accept all request method
#

GET   /             index.index
POST  /index        index.index
*     /home         index.index
GET   /api/test     api.testApi
GET   /api/echo/{msg<.+>}/     api.echo
GET   /api/fact/{n<\d+>}/      api.fact
\end{minted}


\chapter{Ключи команды \texttt{ldc2}}\label{chap:cmds}
\begin{minted}{text}
stud@sysrescue:~/go$ ldc2 --help
OVERVIEW: LDC - the LLVM D compiler

USAGE: ldc2 [options] files --run Runs the resulting program, passing the remaining arguments to it

OPTIONS:

General options:

  -D                                           - Generate documentation
  --Dd=<directory>                             - Write documentation file to <directory>
  --Df=<filename>                              - Write documentation file to <filename>
  -H                                           - Generate 'header' file
  --HC                                         - Generate C++ header file
                                                 Use -HC=verbose to add comments for ignored declarations (e.g. extern(D))
  --HCd=<directory>                            - Write C++ 'header' file to <directory>
  --HCf=<filename>                             - Write C++ 'header' file to <filename>
  --Hd=<directory>                             - Write 'header' file to <directory>
  --Hf=<filename>                              - Write 'header' file to <filename>
  --Hkeep-all-bodies                           - Keep all function bodies in .di files
  -I <directory>                               - Look for imports also in <directory>
  -J <directory>                               - Look for string imports also in <directory>
  Setting the optimization level:
      -O                                         - Equivalent to -O3
      --O0                                        - No optimizations (default)
      --O1                                        - Simple optimizations
      --O2                                        - Good optimizations
      --O3                                        - Aggressive optimizations
      --O4                                        - Equivalent to -O3
      --O5                                        - Equivalent to -O3
      --Os                                        - Like -O2 with extra optimizations for size
      --Oz                                        - Like -Os but reduces code size further
  -P <cppflag>                                 - Pass <cppflag> to C preprocessor
  -X                                           - Generate JSON file
  --Xf=<filename>                              - Write JSON file to <filename>
  --allinst                                    - Generate code for all template instantiations
  --betterC                                    - Omit generating some runtime information and helper functions
  --boundscheck=<value>                        - Array bounds check
    =off                                       -   Disabled
    =safeonly                                  -   Enabled for @safe functions only
    =on                                        -   Enabled for all functions
  -c                                           - Compile only, do not link
  --cache=<cache dir>                          - Enable compilation cache, using <cache dir> to store cache files
  --cache-prune                                - Enable cache pruning.
  --cache-prune-expiration=<dur>               - Sets the pruning expiration time of cache files to <dur> seconds (default: 1 week). Implies -cache-prune.
  --cache-prune-interval=<dur>                 - Sets the cache pruning interval to <dur> seconds (default: 20 min). Set to 0 to force pruning. Implies -cache-prune.
  --cache-prune-maxbytes=<size>                - Sets the maximum cache size to <size> bytes. Implies -cache-prune.
  --cache-prune-maxpercentage=<perc>           - Sets the cache size limit to <perc> percent of the available space (default: 75%). Implies -cache-prune.
  --cache-retrieval=<value>                    - Set the cache retrieval mechanism (default: copy).
    =copy                                      -   Make a copy of the cache file
    =hardlink                                  -   Create a hard link to the cache file (recommended)
    =link                                      -   Equal to 'hardlink' on Windows, but 'symlink' on Unix and OS X
    =symlink                                   -   Create a symbolic link to the cache file
  --checkaction=<value>                        - Action to take when an assert/boundscheck/final-switch fails
    =D                                         -   Usual D behavior of throwing an AssertError
    =C                                         -   Call the C runtime library assert failure function
    =halt                                      -   Halt the program execution (very lightweight)
    =context                                   -   Use D assert with context information (when available)
  --conf=<filename>                            - Use configuration file <filename>
  --cov                                        - Compile-in code coverage analysis and .lst file generation
                                                 Use -cov=<n> for n% minimum required coverage
                                                 Use -cov=ctfe to include code executed during CTFE
  --cov-increment=<value>                      - Set the type of coverage line count increment instruction
    =default                                   -   Use the default (atomic)
    =atomic                                    -   Atomic increment
    =non-atomic                                -   Non-atomic increment (not thread safe)
    =boolean                                   -   Don't read, just set counter to 1
  --cs-profile-generate                        - Perform context sensitive PGO instrumentation
  --cs-profile-path=<string>                   - Context sensitive profile file path
  Allow deprecated language features and symbols:
      -d                                         - Silently allow deprecated features and symbols
      --dw                                        - Issue a message when deprecated features or symbols are used (default)
      --de                                        - Issue an error when deprecated features or symbols are used (halt compilation)
  --d-debug[=<level/idents>]                     - Compile in debug code >= <level> or identified by <idents>
  --d-version=<level/idents>                   - Compile in version code >= <level> or identified by <idents>
  --deps[=<filename>]                            - Write module dependencies to <filename> (only imports). '-deps' alone prints module dependencies (imports/file/version/debug/lib)
  --enable-asserts=<value>                     - (*) Enable assertions
  --disable-d-passes                           - Disable all D-specific passes
  --disable-gc2stack                           - Disable promotion of GC allocations to stack memory
  --enable-invariants=<value>                  - (*) Enable invariants
  --disable-loop-unrolling                     - Disable loop unrolling in all relevant passes
  --disable-loop-vectorization                 - Disable the loop vectorization pass
  --disable-red-zone                           - Do not emit code that uses the red zone.
  --disable-simplify-drtcalls                  - Disable simplification of druntime calls
  --disable-simplify-libcalls                  - Disable simplification of well-known C runtime calls
  --dllimport=<value>                          - Windows only: which extern(D) global variables to dllimport implicitly if not defined in a root module
    =none                                      -   None (default with -link-defaultlib-shared=false)
    =defaultLibsOnly                           -   Only druntime/Phobos symbols (default with -link-defaultlib-shared and -fvisibility=hidden).
    =all                                       -   All (default with -link-defaultlib-shared and -fvisibility=public)
  --dwarf-version=<int>                        - Dwarf version
  --enable-color=<value>                       - (*) Force colored console output
  --enable-contracts=<value>                   - (*) Enable function pre- and post-conditions
  --enable-inlining=<value>                    - (*) Enable function inlining (default in -O2 and higher)
  --enable-postconditions=<value>              - (*) Enable function postconditions
  --enable-preconditions=<value>               - (*) Enable function preconditions
  --enable-switch-errors=<value>               - (*) Enable runtime errors for unhandled switch cases
  --extern-std=<value>                         - C++ standard for name mangling compatibility
    =c++98                                     -   Sets `__traits(getTargetInfo, "cppStd")` to `199711`
    =c++11                                     -   Sets `__traits(getTargetInfo, "cppStd")` to `201103` (default)
    =c++14                                     -   Sets `__traits(getTargetInfo, "cppStd")` to `201402`
    =c++17                                     -   Sets `__traits(getTargetInfo, "cppStd")` to `201703`
    =c++20                                     -   Sets `__traits(getTargetInfo, "cppStd")` to `202002`
  --fcf-protection                             - Instrument control-flow architecture protection
  --fcf-protection=<value>                     - Instrument control-flow architecture protection
    =none
    =branch
    =return
    =full
  --fdmd-trace-functions                       - DMD-style runtime performance profiling of generated code
  --ffast-math                                 - Set @fastmath for all functions.
  --finstrument-functions                      - Instrument function entry and exit with GCC-compatible profiling calls
  --float-abi=<value>                          - ABI/operations to use for floating-point types:
    =default                                   -   Target default floating-point ABI
    =soft                                      -   Software floating-point ABI and operations
    =softfp                                    -   Soft-float ABI, but hardware floating-point instructions
    =hard                                      -   Hardware floating-point ABI and instructions
  --flto=<value>                               - Set LTO mode, requires linker support
    =full                                      -   Merges all input into a single module
    =thin                                      -   Parallel importing and codegen (faster than 'full')
  --flto-binary=<file>                         - Set the linker LTO plugin library file (e.g. LLVMgold.so (Unixes) or libLTO.dylib (Darwin))
  --fno-delete-null-pointer-checks             - Treat null pointer dereference as defined behavior when optimizing (instead of _un_defined behavior). This prevents the optimizer from assuming that any dereferenced pointer must not have been null and optimize away the branches accordingly.
  --fno-discard-value-names                    - Do not discard value names in LLVM IR
  --fno-plt                                    - Do not use the PLT to make function calls
  --fp-contract=<value>                        - Enable aggressive formation of fused FP ops
    =fast                                      -   Fuse FP ops whenever profitable
    =on                                        -   Only fuse 'blessed' FP ops.
    =off                                       -   Only fuse FP ops when the result won't be affected.
  --fprofile-generate[=<filename>]               - Generate instrumented code to collect a runtime profile into default.profraw (overriden by '=<filename>' or LLVM_PROFILE_FILE env var)
  --fprofile-instr-generate[=<filename>]         - Generate instrumented code to collect a runtime profile into default.profraw (overriden by '=<filename>' or LLVM_PROFILE_FILE env var)
  --fprofile-instr-use=<filename>              - Use instrumentation data for profile-guided optimization
  --fprofile-use=<filename>                    - Use instrumentation data for profile-guided optimization
  --frame-pointer=<value>                      - Specify frame pointer elimination optimization
    =all                                       -   Disable frame pointer elimination
    =non-leaf                                  -   Disable frame pointer elimination for non-leaf frame
    =none                                      -   Enable frame pointer elimination
  --fsanitize=<checks>                         - Turn on runtime checks for various forms of undefined or suspicious behavior.
  --fsanitize-address-use-after-return=<value> - Select the mode of detecting stack use-after-return (UAR) in AddressSanitizer: never | runtime (default) | always
    =never                                     -   Completely disables detection of UAR errors (reduces code size).
    =runtime                                   -   Adds the code for detection, but it can be disabled via the runtime environment (ASAN_OPTIONS=detect_stack_use_after_return=0). Requires druntime support.
    =always                                    -   Enables detection of UAR errors in all cases. (reduces code size, but not as much as never). Requires druntime support.
  --fsanitize-blacklist=<file>                 - Add <file> to the blacklist files for the sanitizers.
  --fsanitize-coverage=<type>                  - Specify the type of coverage instrumentation for -fsanitize
  --fsanitize-memory-track-origins=<int>       - Enable origins tracking in MemorySanitizer (0=disabled, default)
  --fsave-optimization-record[=<filename>]       - Generate a YAML optimization record file of optimizations performed by LLVM
  --fsplit-stack                               - Use segmented stack (see Clang documentation)
  --fthread-model=<value>                      - Thread model
    =global-dynamic                            -   Global dynamic TLS model (default)
    =local-dynamic                             -   Local dynamic TLS model
    =initial-exec                              -   Initial exec TLS model
    =local-exec                                -   Local exec TLS model
  --ftime-trace                                - Turn on time profiler. Generates JSON file based on the output filename (also see --ftime-trace-file).
  --ftime-trace-file=<filename>                - Specify time trace file destination
  --ftime-trace-granularity=<uint>             - Minimum time granularity (in microseconds) traced by time profiler
  --fvisibility=<value>                        - Default visibility of symbols
    =default                                   -   Hidden for Windows targets without -shared, otherwise public
    =hidden                                    -   Only export symbols marked with 'export'
    =public                                    -   Export all symbols
  --fwarn-stack-size=<threshold>               - Warn for stack size bigger than the given number
  --fxray-instruction-threshold=<value>        - Sets the minimum function size to instrument with XRay
  --fxray-instrument                           - Generate XRay instrumentation sleds on function entry and exit
  Generating debug information:
      -g                                         - Add symbolic debug info
      --gc                                        - Add symbolic debug info, optimize for non D debuggers
      --gline-tables-only                         - Add line tables only
  --gdwarf                                     - Emit DWARF debuginfo (instead of CodeView) for MSVC targets
  --hash-threshold=<uint>                      - Hash symbol names longer than this threshold (experimental)
  -i[=<pattern>]                                 - Include imported modules in the compilation
  --ignore                                     - Ignore unsupported pragmas
  --lib                                        - Create static library
      --linkonce-templates                        - Use discardable linkonce_odr linkage for template symbols and lazily & recursively define all referenced instantiated symbols in each object file
      --linkonce-templates-aggressive             - Experimental, more aggressive variant
  --lowmem                                     - Enable the garbage collector for the LDC front-end. This reduces the compiler memory requirements but increases compile times.
  --lto-aix-system-assembler=<path>            - Path to a system assembler, picked up on AIX only
  --lto-pass-remarks-filter=<regex>            - Only record optimization remarks from passes whose names match the given regular expression
  --lto-pass-remarks-format=<format>           - The format used for serializing remarks (default: YAML)
  --lto-pass-remarks-output=<filename>         - Output filename for pass remarks
  --m32                                        - 32 bit target
  --m64                                        - 64 bit target
  --mabi=<string>                              - The name of the ABI to be targeted from the backend
  --main                                       - Add default main() if not present already (e.g. for unittesting)
  --makedeps[=<filename>]                        - Write module dependencies in Makefile compatible format to <filename>/stdout (only imports)
  --march=<string>                             - Architecture to generate code for (see --version)
  --mattr=<a1,+a2,-a3,...>                     - Target specific attributes (-mattr=help for details)
  --mcpu=<cpu-name>                            - Target a specific cpu type (-mcpu=help for details)
  --mdcompute-file-prefix=<prefix>             - Prefix to prepend to the generated kernel files.
  --mdcompute-targets=<targets>                - Generates code for the specified DCompute target list. Use 'ocl-xy0' for OpenCL x.y, and 'cuda-xy0' for CUDA CC x.y
  --mixin=<filename>                           - Expand and save mixins to <filename>
  --mtriple=<string>                           - Override target triple
  --mv=<<package.module>=<filespec>>           - Use <filespec> as source file for <package.module>
  --noasm                                      - Disallow use of inline assembler
  --nogc                                       - Do not allow code that generates implicit garbage collector calls
  --o-                                         - Do not write object file
  --od=<directory>                             - Write object files to <directory>
  --of=<filename>                              - Use <filename> as output file name
  --op                                         - Preserve source path for output files
  --oq                                         - Write object files with fully qualified names
  --output-bc                                  - Write LLVM bitcode
  --output-ll                                  - Write LLVM IR
  --output-mlir                                - Write MLIR
  --output-o                                   - Write native object
  --output-s                                   - Write native assembly
  --passmanager=<value>                        - Setting the passmanager (new,legacy):
    =legacy                                    -   Use the legacy passmanager (available for LLVM14 and below)
    =new                                       -   Use the new passmanager (available for LLVM14 and above)
  --plugin=<dynamic_library.so,lib2.so>        - Pass plugins to load.
  --preview=<name>                             - Enable an upcoming language change identified by <name>, use ? for list
  --release                                    - Compile release version, defaulting to disabled asserts/contracts/invariants, and bounds checks in @safe functions only
  --relocation-model=<value>                   - Choose relocation model
    =static                                    -   Non-relocatable code
    =pic                                       -   Fully relocatable, position independent code
    =dynamic-no-pic                            -   Relocatable external references, non-relocatable code
    =ropi                                      -   Code and read-only data relocatable, accessed PC-relative
    =rwpi                                      -   Read-write data relocatable, accessed relative to static base
    =ropi-rwpi                                 -   Combination of ropi and rwpi
  --revert=<name>                              - Revert language change identified by <name>, use ? for list
  --run <string>...                            - Runs the resulting program, passing the remaining arguments to it
  --shared                                     - Create shared library (DLL)
  --singleobj                                  - Create only a single output object file
  --template-depth=<uint>                      - Set maximum number of nested template instantiations
  --threads=<int>                              -
  --transition=<name>                          - Help with language change identified by <name>, use ? for list
  --unittest                                   - Compile in unit tests
  -v                                           - Verbose
  --v-cg                                       - Verbose codegen
  --vcolumns                                   - Print character (column) numbers in diagnostics
  --verror-style=<value>                       - Set the style for file/line number annotations on compiler messages
    =digitalmars                               -   'file(line[,column]): message' (default)
    =gnu                                       -   'file:line[:column]: message', conforming to the GNU standard used by gcc and clang
  --verror-supplements=<uint>                  - Limit the number of supplemental messages for each error (0 means unlimited)
  --verrors=<uint>                             - Limit the number of error messages (0 means unlimited)
  --verrors-context                            - Show error messages with the context of the erroring source line
  --verrors-spec                               - Show errors from speculative compiles such as __traits(compiles,...)
  --vgc                                        - List all gc allocations including hidden ones
  --vtemplates                                 - List statistics on template instantiations
                                                 Use -vtemplates=list-instances to additionally show all instantiation contexts for each template
  --vv                                         - Print front-end/glue code debug log
  Warnings:
      -w                                         - Enable warnings as errors (compilation will halt)
      --wi                                        - Enable warnings as messages (compilation will continue)
  --wo                                         - Enable warnings about use of obsolete features

Generic Options:

  --help                                       - Display available options (--help-hidden for more)
  --help-list                                  - Display list of available options (--help-list-hidden for more)
  --version                                    - Display the version of this program

Linking options:

  -L <linkerflag>                              - Pass <linkerflag> to the linker
  --Xcc=<ccflag>                               - Pass <ccflag> to GCC/Clang for linking/preprocessing
  --defaultlib=<lib1,lib2,...>                 - Default libraries to link with (overrides previous)
  --disable-linker-strip-dead                  - Do not try to remove unused symbols during linking
  --gcc=<gcc|clang|...>                        - C compiler to use for linking (and external assembling). Defaults to the CC environment variable if set, otherwise to `cc`.
  --link-defaultlib-debug                      - Link with debug versions of default libraries
  --link-defaultlib-shared                     - Link with shared versions of default libraries. Defaults to true when generating a shared library (-shared).
  --linker=<lld-link|lld|gold|bfd|...>         - Set the linker to use. When explicitly set to '' (nothing), prevents LDC from passing `-fuse-ld` to `cc`.
  --mscrtlib=<libcmt[d]|msvcrt[d]>             - MS C runtime library to link with
  --platformlib=<lib1,lib2,...>                - Platform libraries to link with (overrides previous)
  --static                                     - Create a statically linked binary, including all system dependencies

Polly Options:
Configure the polly loop optimizer

  --polly                                      - Enable the polly optimizer (with -O1, -O2 or -O3)
  --polly-2nd-level-tiling                     - Enable a 2nd level loop of loop tiling
  --polly-ast-print-accesses                   - Print memory access functions
  --polly-context=<isl parameter set>          - Provide additional constraints on the context parameters
  --polly-dce-precise-steps=<int>              - The number of precise steps between two approximating iterations. (A value of -1 schedules another approximation stage before the actual dead code elimination.
  --polly-delicm-max-ops=<int>                 - Maximum number of isl operations to invest for lifetime analysis; 0=no limit
  --polly-detect-full-functions                - Allow the detection of full functions
  --polly-enable-simplify                      - Simplify SCoP after optimizations
  --polly-ignore-func=<string>                 - Ignore functions that match a regex. Multiple regexes can be comma separated. Scop detection will ignore all functions that match ANY of the regexes provided.
  --polly-isl-arg=<argument>                   - Option passed to ISL
  --polly-matmul-opt                           - Perform optimizations of matrix multiplications based on pattern matching
  --polly-on-isl-error-abort                   - Abort if an isl error is encountered
  --polly-only-func=<string>                   - Only run on functions that match a regex. Multiple regexes can be comma separated. Scop detection will run on all functions that match ANY of the regexes provided.
  --polly-only-region=<identifier>             - Only run on certain regions (The provided identifier must appear in the name of the region's entry block
  --polly-only-scop-detection                  - Only run scop detection, but no other optimizations
  --polly-optimized-scops                      - Polly - Dump polyhedral description of Scops optimized with the isl scheduling optimizer and the set of post-scheduling transformations is applied on the schedule tree
  --polly-parallel                             - Generate thread parallel code (isl codegen only)
  --polly-parallel-force                       - Force generation of thread parallel code ignoring any cost model
  --polly-pattern-matching-based-opts          - Perform optimizations based on pattern matching
  --polly-postopts                             - Apply post-rescheduling optimizations such as tiling (requires -polly-reschedule)
  --polly-pragma-based-opts                    - Apply user-directed transformation from metadata
  --polly-pragma-ignore-depcheck               - Skip the dependency check for pragma-based transformations
  --polly-process-unprofitable                 - Process scops that are unlikely to benefit from Polly optimizations.
  --polly-register-tiling                      - Enable register tiling
  --polly-report                               - Print information about the activities of Polly
  --polly-reschedule                           - Optimize SCoPs using ISL
  --polly-show                                 - Highlight the code regions that will be optimized in a (CFG BBs and LLVM-IR instructions)
  --polly-show-only                            - Highlight the code regions that will be optimized in a (CFG only BBs)
  --polly-stmt-granularity=<value>             - Algorithm to use for splitting basic blocks into multiple statements
    =bb                                        -   One statement per basic block
    =scalar-indep                              -   Scalar independence heuristic
    =store                                     -   Store-level granularity
  --polly-tc-opt                               - Perform optimizations of tensor contractions based on pattern matching
  --polly-tiling                               - Enable loop tiling
  --polly-vectorizer=<value>                   - Select the vectorization strategy
    =none                                      -   No Vectorization
    =polly                                     -   Polly internal vectorizer
    =stripmine                                 -   Strip-mine outer loops for the loop-vectorizer to trigger

-d-debug can also be specified without options, in which case it enables all debug checks (i.e. asserts, boundschecks, contracts and invariants) as well as acting as -d-debug=1.

Boolean options can take an optional value, e.g., -link-defaultlib-shared=<true,false>.
Boolean options marked with (*) also have a -disable-FOO variant with inverted meaning.
\end{minted}

\end{document}




%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
